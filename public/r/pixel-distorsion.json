{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "pixel-distorsion",
  "type": "registry:ui",
  "dependencies": [
    "clsx tailwind-merge @react-three/fiber @react-three/drei three"
  ],
  "files": [
    {
      "path": "registry/new-york-v4/ui/pixel-distorsion.tsx",
      "content": "\"use client\"\n\nimport React, { useCallback, useEffect, useRef } from \"react\"\nimport { useTexture } from \"@react-three/drei\"\nimport { ThreeEvent, useFrame } from \"@react-three/fiber\"\nimport * as THREE from \"three\"\n\nimport {\n  fragment,\n  vertex,\n} from \"@/registry/new-york-v4/ui/pixel-distorsion-shader\"\n\ninterface PixelDistorsionProps {\n  imageSrc: string\n  canvasWidth: number\n  canvasHeight: number\n  grid?: number\n  mouse?: number\n  strength?: number\n}\n\nexport default function PixelDistorsion({\n  imageSrc,\n  canvasWidth,\n  canvasHeight,\n  grid = 20,\n  mouse = 0.25,\n  strength = 0.2,\n}: PixelDistorsionProps) {\n  const plane = useRef<THREE.Mesh>(null)\n  const texture = useTexture(imageSrc)\n  const mouseState = useRef({ x: 0.5, y: 0.5, vX: 0, vY: 0 })\n\n  const uniforms = useRef({\n    uTexture: { value: texture },\n    uTime: { value: 0 },\n    uHover: { value: new THREE.Vector2(0.5, 0.5) },\n    uDataTexture: { value: null as THREE.DataTexture | null },\n    resolution: { value: new THREE.Vector4() },\n  })\n\n  const generateDataTexture = useCallback(() => {\n    const data = new Float32Array(grid * grid * 4)\n    for (let i = 0; i < grid * grid; i++) {\n      const stride = i * 4\n      data[stride] = Math.random()\n      data[stride + 1] = Math.random()\n      data[stride + 2] = Math.random()\n      data[stride + 3] = 1.0\n    }\n    const dataTexture = new THREE.DataTexture(\n      data,\n      grid,\n      grid,\n      THREE.RGBAFormat,\n      THREE.FloatType\n    )\n    dataTexture.needsUpdate = true\n    dataTexture.minFilter = THREE.NearestFilter\n    dataTexture.magFilter = THREE.NearestFilter\n    return dataTexture\n  }, [grid])\n\n  useEffect(() => {\n    uniforms.current.uDataTexture.value = generateDataTexture()\n  }, [generateDataTexture])\n\n  useEffect(() => {\n    uniforms.current.resolution.value.set(canvasWidth, canvasHeight, 1, 1)\n  }, [canvasWidth, canvasHeight])\n\n  const settings = { grid, mouseInfluence: mouse, strength, relaxation: 0.9 }\n\n  const clamp = (number: number, min: number, max: number) =>\n    Math.max(min, Math.min(number, max))\n\n  const updateDataTexture = () => {\n    const dataTexture = uniforms.current.uDataTexture?.value\n    if (!dataTexture || !dataTexture.image?.data) return\n\n    const data = dataTexture.image.data as Float32Array\n    const gridMouseX = mouseState.current.x * settings.grid\n    const gridMouseY = (1 - mouseState.current.y) * settings.grid\n    const maxDist = settings.grid * settings.mouseInfluence\n    const aspect = canvasHeight / canvasWidth\n\n    for (let i = 0; i < data.length; i += 4) {\n      data[i] *= settings.relaxation\n      data[i + 1] *= settings.relaxation\n    }\n\n    for (let i = 0; i < settings.grid; i++) {\n      for (let j = 0; j < settings.grid; j++) {\n        const distance = (gridMouseX - i) ** 2 / aspect + (gridMouseY - j) ** 2\n        const maxDistSq = maxDist ** 2\n\n        if (distance < maxDistSq) {\n          const index = 4 * (i + settings.grid * j)\n          let power = maxDist / Math.sqrt(distance)\n          power = clamp(power, 0, 10)\n\n          data[index] += settings.strength * mouseState.current.vX * power * 100\n          data[index + 1] -=\n            settings.strength * mouseState.current.vY * power * 100\n        }\n      }\n    }\n    mouseState.current.vX *= 0.9\n    mouseState.current.vY *= 0.9\n\n    requestAnimationFrame(() => {\n      if (dataTexture) dataTexture.needsUpdate = true\n    })\n  }\n\n  useEffect(() => {\n    const dataTexture = generateDataTexture()\n    uniforms.current.uDataTexture.value = dataTexture\n\n    return () => {\n      dataTexture?.dispose()\n      texture?.dispose()\n    }\n  }, [generateDataTexture, texture])\n\n  const handlePointerMove = (event: ThreeEvent<PointerEvent>) => {\n    const { offsetX, offsetY } = event.nativeEvent\n    mouseState.current.vX = offsetX / canvasWidth - mouseState.current.x\n    mouseState.current.vY = offsetY / canvasHeight - mouseState.current.y\n    mouseState.current.x = offsetX / canvasWidth\n    mouseState.current.y = offsetY / canvasHeight\n  }\n\n  useFrame((state) => {\n    if (plane.current) {\n      ;(plane.current.material as THREE.ShaderMaterial).uniforms.uTime.value =\n        state.clock.elapsedTime\n      updateDataTexture()\n    }\n  })\n\n  return (\n    <mesh ref={plane} onPointerMove={handlePointerMove}>\n      <planeGeometry args={[canvasWidth, canvasHeight, 45, 45]} />\n      <shaderMaterial\n        side={THREE.DoubleSide}\n        vertexShader={vertex}\n        fragmentShader={fragment}\n        uniforms={uniforms.current}\n      />\n    </mesh>\n  )\n}\n",
      "type": "registry:ui"
    },
    {
      "path": "registry/new-york-v4/ui/pixel-distorsion-scene.tsx",
      "content": "\"use client\"\n\nimport React, { useCallback, useEffect, useRef, useState } from \"react\"\nimport { Canvas } from \"@react-three/fiber\"\nimport * as THREE from \"three\"\n\nimport PixelDistorsion from \"@/registry/new-york-v4/ui/pixel-distorsion\"\n\ninterface PixelDistorsionSceneProps {\n  imageSrc: string\n  alt?: string\n  grid?: number\n  mouse?: number\n  strength?: number\n}\n\nexport default function PixelDistorsionScene({\n  imageSrc,\n  alt,\n  grid = 20,\n  mouse = 0.25,\n  strength = 0.2,\n}: PixelDistorsionSceneProps) {\n  const [isMobile, setIsMobile] = useState(window.innerWidth < 768)\n  const cameraRef = useRef<THREE.PerspectiveCamera | null>(null)\n  const containerRef = useRef<HTMLDivElement>(null)\n  const [dimensions, setDimensions] = useState({ width: 0, height: 0 })\n  const [key, setKey] = useState(0)\n\n  const updateDimensions = useCallback(() => {\n    if (!containerRef.current || !window) return\n\n    const parentWidth = Math.max(1, containerRef.current.clientWidth || 1)\n    setIsMobile(window.innerWidth < 640)\n    const img = new Image()\n    img.src = imageSrc\n    img.onload = () => {\n      const aspect = img.width / img.height\n      const newHeight = parentWidth / aspect\n      setDimensions({ width: parentWidth, height: newHeight })\n\n      if (!isMobile) {\n        const newDistance = newHeight / 2 / Math.tan((45 * Math.PI) / 360)\n        if (cameraRef.current) {\n          cameraRef.current.position.set(0, 0, newDistance)\n          cameraRef.current.updateProjectionMatrix()\n        }\n      }\n    }\n  }, [imageSrc, isMobile])\n\n  useEffect(() => {\n    updateDimensions()\n    const observer = new ResizeObserver(() => {\n      requestAnimationFrame(updateDimensions)\n    })\n    window.addEventListener(\"resize\", updateDimensions)\n\n    if (containerRef.current) observer.observe(containerRef.current)\n    return () => {\n      observer.disconnect()\n      window.removeEventListener(\"resize\", updateDimensions)\n    }\n  }, [updateDimensions])\n\n  useEffect(() => {\n    const timer = setTimeout(() => {\n      setKey(1)\n    }, 100)\n\n    return () => clearTimeout(timer)\n  }, [])\n\n  const handleCanvasCreated = useCallback(\n    ({ camera }: { camera: THREE.Camera }) => {\n      cameraRef.current = camera as THREE.PerspectiveCamera\n    },\n    []\n  )\n\n  return (\n    <div\n      ref={containerRef}\n      style={{ width: \"100%\", height: dimensions.height }}\n    >\n      {isMobile ? (\n        <img\n          src={imageSrc}\n          alt={alt || \"Shader preview\"}\n          style={{ width: \"100%\", height: \"100%\", objectFit: \"cover\" }}\n        />\n      ) : (\n        <Canvas\n          key={key}\n          camera={{\n            fov: 45,\n            aspect: dimensions.width / dimensions.height,\n            near: 0.1,\n            far: 1000,\n            position: [\n              0,\n              0,\n              dimensions.height / 2 / Math.tan((45 * Math.PI) / 360),\n            ],\n          }}\n          onCreated={handleCanvasCreated}\n          style={{ width: \"100%\", height: \"100%\" }}\n        >\n          <PixelDistorsion\n            imageSrc={imageSrc}\n            canvasWidth={dimensions.width}\n            canvasHeight={dimensions.height}\n            grid={grid}\n            mouse={mouse}\n            strength={strength}\n          />\n        </Canvas>\n      )}\n    </div>\n  )\n}\n",
      "type": "registry:ui"
    },
    {
      "path": "registry/new-york-v4/ui/pixel-distorsion-shader.tsx",
      "content": "export const vertex = `\nuniform float time;\nvarying vec2 vUv;\nvarying vec3 vPosition;\nuniform vec2 pixels;\nfloat PI = 3.141592653589793238;\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}\n`\n\nexport const fragment = `\nuniform float time;\nuniform float progress;\nuniform sampler2D uDataTexture;\nuniform sampler2D uTexture;\n \nuniform vec4 resolution;\nvarying vec2 vUv;\nvarying vec3 vPosition;\nfloat PI = 3.141592653589793238;\nvoid main()\t{\n  vec2 newUV = (vUv - vec2(0.5))*resolution.zw + vec2(0.5);\n  vec4 color = texture2D(uTexture,newUV);\n  vec4 offset = texture2D(uDataTexture,vUv);\n  gl_FragColor = vec4(vUv,0.0,1.);\n  gl_FragColor = vec4(offset.r,0.,0.,1.);\n  gl_FragColor = color;\n  gl_FragColor = texture2D(uTexture,newUV - 0.02*offset.rg);\n}\n`\n",
      "type": "registry:ui"
    }
  ]
}