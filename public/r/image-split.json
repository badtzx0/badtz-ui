{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "image-split",
  "type": "registry:ui",
  "dependencies": [
    "clsx",
    "tailwind-merge"
  ],
  "files": [
    {
      "path": "registry/new-york-v4/ui/image-split.tsx",
      "content": "\"use client\"\n\nimport React, { useEffect, useRef, useState } from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\ninterface ImageSplitProps extends React.HTMLAttributes<HTMLDivElement> {\n  src: string\n  sections?: number\n  offsetStep?: number\n  initialBorderOpacity?: number\n  enableBorder?: boolean\n  borderColor?: string\n  viewportThreshold?: number\n  className?: string\n}\n\nconst hexToRgb = (hex: string): string | null => {\n  const validHex = /^#?([a-fA-F0-9]{3}|[a-fA-F0-9]{6})$/.test(hex)\n  if (!validHex) return null\n\n  let cleanHex = hex.replace(\"#\", \"\")\n\n  if (cleanHex.length === 3) {\n    cleanHex = cleanHex\n      .split(\"\")\n      .map((char) => char + char)\n      .join(\"\")\n  }\n\n  const bigint = parseInt(cleanHex, 16)\n  const r = (bigint >> 16) & 255\n  const g = (bigint >> 8) & 255\n  const b = bigint & 255\n\n  return `${r}, ${g}, ${b}`\n}\n\nexport function ImageSplit({\n  src,\n  sections = 9,\n  offsetStep = 30,\n  initialBorderOpacity = 0.4,\n  enableBorder = true,\n  borderColor = \"#ffffff\",\n  viewportThreshold = 0.3,\n  className,\n  ...props\n}: ImageSplitProps) {\n  const [imagePieces, setImagePieces] = useState<string[]>([])\n  const [borderOpacity, setBorderOpacity] =\n    useState<number>(initialBorderOpacity)\n  const [progress, setProgress] = useState<number>(0)\n  const canvasRef = useRef<HTMLCanvasElement | null>(null)\n  const parentRef = useRef<HTMLDivElement | null>(null)\n  const imgRefs = useRef<(HTMLImageElement | null)[]>([])\n  const scrollContainerRef = useRef<HTMLElement | null>(null)\n  const animationFrameRef = useRef<number>(0)\n  const borderRgb = hexToRgb(borderColor) || \"255, 255, 255\"\n\n  useEffect(() => {\n    const image = new Image()\n    image.src = src\n    image.onload = () => cutImageUp(image)\n  }, [src, sections])\n\n  useEffect(() => {\n    setBorderOpacity(progress * initialBorderOpacity)\n  }, [progress])\n\n  useEffect(() => {\n    const parent = parentRef.current\n    if (!parent) return\n\n    scrollContainerRef.current = getScrollParent(parent)\n    setupScrollListener()\n\n    return () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current)\n      }\n    }\n  }, [])\n\n  const getScrollParent = (element: HTMLElement | null): HTMLElement | null => {\n    while (element) {\n      const style = getComputedStyle(element)\n      if ([\"auto\", \"scroll\"].includes(style.overflowY)) return element\n      if (!element.parentElement) return null\n      element = element.parentElement\n    }\n    return null\n  }\n\n  const setupScrollListener = () => {\n    const scrollContainer = scrollContainerRef.current\n    const parent = parentRef.current\n    if (!parent) return\n\n    const updateProgress = () => {\n      const parentRect = parent.getBoundingClientRect()\n      const viewportHeight = window.innerHeight\n\n      let progress\n      if (scrollContainer instanceof HTMLElement) {\n        const scrollContainerRect = scrollContainer.getBoundingClientRect()\n        const start = scrollContainerRect.bottom\n        const end = scrollContainerRect.top + viewportHeight * viewportThreshold\n        const current = parentRect.top\n        progress = (current - end) / (start - end)\n      } else {\n        const startTrigger = viewportHeight * viewportThreshold\n        const elementTop = parentRect.top\n        const elementHeight = parentRect.height\n\n        progress =\n          (elementTop - startTrigger) /\n          (viewportHeight - elementHeight - startTrigger)\n      }\n\n      progress = Math.min(1, Math.max(0, progress))\n      setProgress(progress)\n\n      imgRefs.current.forEach((img, index) => {\n        if (!img) return\n        const offset = getOffset(index)\n        img.style.transform = `translateY(${offset * progress}px)`\n      })\n    }\n\n    const handleScroll = () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current)\n      }\n      animationFrameRef.current = requestAnimationFrame(updateProgress)\n    }\n\n    const target = scrollContainer || window\n    target.addEventListener(\"scroll\", handleScroll, { passive: true })\n    handleScroll()\n\n    return () => target.removeEventListener(\"scroll\", handleScroll)\n  }\n\n  const cutImageUp = (image: HTMLImageElement) => {\n    const canvas = canvasRef.current\n    if (!canvas) return\n\n    const pieceWidth = Math.floor(image.width / sections)\n    const pieceHeight = image.height\n    const context = canvas.getContext(\"2d\")\n    if (!context) return\n\n    const newImagePieces: string[] = []\n    for (let i = 0; i < sections; i++) {\n      canvas.width = pieceWidth\n      canvas.height = pieceHeight\n      context.clearRect(0, 0, canvas.width, canvas.height)\n      context.drawImage(\n        image,\n        i * pieceWidth,\n        0,\n        pieceWidth,\n        pieceHeight,\n        0,\n        0,\n        pieceWidth,\n        pieceHeight\n      )\n      newImagePieces.push(canvas.toDataURL())\n    }\n    setImagePieces(newImagePieces)\n  }\n\n  const getOffset = (index: number) => {\n    if (index === 0 || index === sections - 1) return 0\n    return Math.min(index, sections - 1 - index) * offsetStep\n  }\n\n  return (\n    <div\n      ref={parentRef}\n      className={cn(\"relative flex w-full rounded-[inherit]\", className)}\n      {...props}\n    >\n      <canvas ref={canvasRef} className=\"hidden\" />\n\n      {imagePieces.map((piece, index) => (\n        <img\n          key={index}\n          src={piece}\n          alt={`section-${index}`}\n          ref={(el: HTMLImageElement | null) => {\n            imgRefs.current[index] = el\n          }}\n          className={cn(\n            \"object-contain transition-transform duration-300 ease-out\",\n            {\n              \"rounded-l-[inherit]\": index === 0,\n              \"rounded-r-[inherit]\": index === imagePieces.length - 1,\n            }\n          )}\n          style={{\n            width: `${100 / sections}%`,\n            transform: `translateY(${getOffset(index)}px)`,\n            zIndex: sections - index,\n            borderRight:\n              enableBorder && index !== imagePieces.length - 1\n                ? `1px solid rgba(${borderRgb}, ${borderOpacity})`\n                : \"none\",\n            marginRight:\n              enableBorder && index !== imagePieces.length - 1 ? \"-1px\" : \"0\",\n            boxSizing: \"border-box\",\n          }}\n        />\n      ))}\n    </div>\n  )\n}\n",
      "type": "registry:ui"
    }
  ]
}